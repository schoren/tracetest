"use strict";(self.webpackChunktracetest_docs=self.webpackChunktracetest_docs||[]).push([[1754],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>g});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(r),h=a,g=u["".concat(c,".").concat(h)]||u[h]||d[h]||o;return r?n.createElement(g,s(s({ref:t},p),{},{components:r})):n.createElement(g,s({ref:t},p))}));function g(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},49525:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=r(87462),a=(r(67294),r(3905));const o={},s="Sampling Tracetest Spans",i={unversionedId:"configuration/sampling-tracetest-spans",id:"configuration/sampling-tracetest-spans",title:"Sampling Tracetest Spans",description:"Suppose you are considering Tracetest to run tests against a high-volume environment, such as production. In that case, you probably will hit some drawbacks, such as having",source:"@site/docs/configuration/sampling-tracetest-spans.md",sourceDirName:"configuration",slug:"/configuration/sampling-tracetest-spans",permalink:"/configuration/sampling-tracetest-spans",draft:!1,editUrl:"https://github.com/kubeshop/tracetest/blob/main/docs/docs/configuration/sampling-tracetest-spans.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Demo Settings",permalink:"/configuration/demo"},next:{title:"What is Trace-Based Testing",permalink:"/concepts/what-is-trace-based-testing"}},c={},l=[{value:"Add a Separate Pipeline for Tracetest in your OpenTelemetry Collector",id:"add-a-separate-pipeline-for-tracetest-in-your-opentelemetry-collector",level:2},{value:"Consider Trace-related Headers in your Ingress Endpoint",id:"consider-trace-related-headers-in-your-ingress-endpoint",level:2}],p={toc:l},u="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(u,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"sampling-tracetest-spans"},"Sampling Tracetest Spans"),(0,a.kt)("p",null,"Suppose you are considering Tracetest to run tests against a high-volume environment, such as production. In that case, you probably will hit some drawbacks, such as having\nyour test spans not sampled by your probabilistic sampler. There are a couple of things that you can do to avoid those problems:"),(0,a.kt)("h2",{id:"add-a-separate-pipeline-for-tracetest-in-your-opentelemetry-collector"},"Add a Separate Pipeline for Tracetest in your OpenTelemetry Collector"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Note: This requires the ",(0,a.kt)("a",{parentName:"p",href:"https://hub.docker.com/r/otel/opentelemetry-collector-contrib"},"OpenTelemetry collector contrib")," instead of the core release\nof the collector")),(0,a.kt)("p",null,"Your existing OpenTelemetry Collector already receives traces from your applications and sends them to your datastore and you have a set of processors configured to ensure the quality of the traces your datastore is receiving. It probably looks like this one:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"receivers:\n  otlp:\n    protocols:\n      grpc:\n      http:\n\nprocessors:\n  probabilistic_sampler:\n    hash_seed: 22\n    sampling_percentage: 5.0\n\n  batch:\n\nexporters:\n  otlp/jaeger:\n    endpoint: jaeger:4317\n    tls:\n      insecure: true\n\nservice:\n  pipelines:\n    traces/jaeger:\n      receivers: [otlp]\n      processors: [tail_sampling, batch]\n      exporters: [otlp/jaeger]\n")),(0,a.kt)("p",null,"We don't want to change this pipeline for your testing to work, so let's create a new pipeline for collecting only traces generated by Tracetest tests:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'receivers:\n  otlp:\n    protocols:\n      grpc:\n      http:\n\nprocessors:\n  probabilistic_sampler:\n    hash_seed: 22\n    sampling_percentage: 5.0\n\n  batch:\n\n  # Filters spans that have the tracestate `tracetest=true` in their context. This value\n  # is injected by Tracetest when triggering the test\n  #\n  # Note: this requires the `collector-contrib` version of the collector\n  tail_sampling:\n    decision_wait: 5s\n    policies:\n      - name: tracetest-spans\n        type: trace_state\n        trace_state: { key: tracetest, values: ["true"] }\n\nexporters:\n  otlp/jaeger:\n    endpoint: jaeger:4317\n    tls:\n      insecure: true\n\nservice:\n  pipelines:\n    traces/jaeger:\n      receivers: [otlp]\n      processors: [tail_sampling, batch]\n      exporters: [otlp/jaeger]\n\n  pipelines:\n    traces/tracetest:\n      receivers: [otlp]\n      processors: [tail_sampling, batch]\n      exporters: [otlp/jaeger]\n')),(0,a.kt)("p",null,"With this configuration, you will still get 5% of all your traces, but you will also ensure that all your test traces are collected and sent to\nJaeger."),(0,a.kt)("h2",{id:"consider-trace-related-headers-in-your-ingress-endpoint"},"Consider Trace-related Headers in your Ingress Endpoint"),(0,a.kt)("p",null,"When exposing something to the internet, it's common to ignore all unknown headers from an HTTP request. This usually includes the ",(0,a.kt)("inlineCode",{parentName:"p"},"traceparent")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"tracestate")," headers, which are the two headers defined in the ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/trace-context/#relationship-between-the-headers"},"W3C specification"),"."),(0,a.kt)("p",null,"However, supporting those two fields can be beneficial. For starters, you can start testing your application in production using Tracetest. If your product APIs are used directly by your customers, you can also share the same Trace-ID as them and use this to correlate a faulty operation on their side with your trace."))}d.isMDXComponent=!0}}]);